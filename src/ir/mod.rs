mod expr;
pub use expr::*;
mod types;
pub use types::*;
mod env;
pub use env::*;

/// Get the size of something in memory (number of cells).
pub trait GetSize {
    /// Get the size of something in memory (number of cells).
    fn get_size(&self, env: &Env) -> Result<usize, Error> {
        self.get_size_checked(env, 0)
    }

    /// Get the size of something in memory, but limit the number of recursive
    /// calls to prevent stack overflow. `i` is a counter to prevent infinite
    /// recursion.
    fn get_size_checked(&self, env: &Env, i: usize) -> Result<usize, Error>;
}

/// Simplify an expression while maintaining structural equality.
pub trait Simplify: Sized {
    /// Simplify an expression while maintaining structural equality.
    fn simplify(self, env: &Env) -> Result<Self, Error> {
        self.simplify_checked(env, 0)
    }

    /// Simplify an expression while maintaining structural equality, but limit
    /// the number of recursive calls to prevent stack overflow. `i` is a
    /// counter to prevent infinite recursion.
    fn simplify_checked(self, env: &Env, i: usize) -> Result<Self, Error>;
}

#[derive(Clone, Debug, PartialEq)]
pub enum Error {
    /// An error caused by trying to assemble invalid code generated by the compiler.
    /// This should be taken seriously, unless the error is due to an invalid handwritten builtin.
    AssemblyError(crate::asm::Error),

    /// The variant of an enum is not defined.
    VariantNotFound(Type, String),
    /// Tried to access an undefined member of a tuple, struct, or union.
    MemberNotFound(Expr, ConstExpr),
    /// Recursion depth exceeded when trying to evaluate a constant expression.
    RecursionDepthConst(ConstExpr),
    /// Recursion depth exceeded when trying to confirm a type's equality to another type.
    RecursionDepthTypeEquality(Type, Type),
    /// Got another type when expecting an integer, bool, or char.
    NonIntegralConst(ConstExpr),
    /// Tried to instantiate a type that cannot be sized.
    /// This is a problem because we cannot manage the stack if we cannot know the size of the type.
    UnsizedType(Type),
    /// Tried to dereference a non-pointer.
    DerefNonPointer(Expr),
    /// Tried to apply a non-procedure to some arguments.
    ApplyNonProc(Expr),
    /// Expected a symbol, but got something else.
    NonSymbol(ConstExpr),
    /// Invalid `Index` expression (incorrect types).
    InvalidIndex(Expr),
    /// Invalid `Refer` expression. The compiler was not able to calculate the address of the expression.
    InvalidRefer(Expr),
    /// Invalid binary operation (add, subtract, and, or) expression (incorrect types).
    InvalidBinop(Expr),

    /// Mismatched types
    MismatchedTypes {
        expected: Type,
        found: Type,
        expr: Expr,
    },

    /// A symbol was used, but not defined.
    SymbolNotDefined(String),
    /// A type was used, but not defined.
    TypeNotDefined(String),

    /// Invalid type casting expression.
    InvalidAs(Expr),
}

/// Create an IR error from an assembly error.
impl From<crate::asm::Error> for Error {
    fn from(e: crate::asm::Error) -> Self {
        Self::AssemblyError(e)
    }
}
